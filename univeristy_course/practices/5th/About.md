## 5 практическая

**Кратко:**
Асинхронность, Coroutines, оффлайн-режим и кеширование данных.

Суть задания:

### 1 — Асинхронность как обязательное условие

На предыдущих этапах вы уже использовали coroutines, но теперь это становится обязательным требованием архитектуры. Все операции, связанные с сетью и хранением данных, должны выполняться **не в главном потоке**.

Repository должен предоставлять `suspend`-методы, а UI — вызывать их асинхронно. Приложение не должно блокировать интерфейс ни при каких условиях, даже при медленном интернете или большом объёме данных.

### 2 — Добавление оффлайн-режима

Приложение должно корректно работать в ситуации, когда интернет недоступен.

Если данные уже были получены ранее, они должны отображаться без повторного сетевого запроса. Если данных нет вовсе — пользователь должен увидеть понятное сообщение, а не пустой экран.

Оффлайн-режим реализуется через локальное хранение данных. Пока не требуется полноценная база данных — достаточно простого механизма сохранения и чтения.

### 3 — Кеширование данных

Необходимо реализовать кеширование результатов сетевого запроса.

Если пользователь делает один и тот же запрос повторно, приложение не должно каждый раз обращаться к серверу. Вместо этого используются сохранённые данные.

Repository теперь отвечает за выбор источника данных:

* сначала локальное хранилище
* при необходимости — сеть
* сохранение результата для дальнейшего использования

Важно, чтобы эта логика была скрыта от UI.

### 4 — Работа с состояниями

Во время загрузки данных приложение должно показывать, что происходит. Пользователь должен понимать:

* идёт загрузка
* данные взяты из кеша
* произошла ошибка

Состояния экрана могут быть реализованы простым способом, без ViewModel и MVVM. Главное — чтобы логика была осознанной, а не случайной.

### 5 — Обработка ошибок

Необходимо корректно обрабатывать:

* отсутствие интернет-соединения
* ошибку сервера
* пустой ответ

Приложение не должно падать и не должно «молчать». Пользователь всегда должен получать обратную связь.

### 6 — Обновление Repository

Repository становится центральным элементом логики.

Теперь именно он решает:

* откуда брать данные
* когда обращаться к сети
* когда использовать кеш

UI по-прежнему не знает, каким образом получены данные, и не должен знать.

### Критерии приёмки

* Все сетевые операции выполняются асинхронно
* Реализован оффлайн-режим
* Данные кешируются и повторно используются
* Repository инкапсулирует логику выбора источника данных
* Приложение корректно обрабатывает отсутствие интернета
* UI не блокируется во время загрузки

### Что прикреплять

zip файл, в котором:

* zip проекта
* README.txt с:

  * ссылкой на git-репозиторий
  * описанием реализации оффлайн-режима
  * пояснением, как работает кеширование
* Скрин экрана приложения в оффлайн-режиме
* Скрин экрана приложения с загруженными данными
