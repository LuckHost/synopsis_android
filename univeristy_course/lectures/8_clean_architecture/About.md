## Лекция 8 — Архитектуры в Android разработке и Clean Architecture

До этого момента мы уже использовали архитектуру, даже если не называли её по имени.
У нас были слои, ответственность, репозитории, ViewModel и UI.
Осталось сделать последний шаг — понять, **что всё это вместе означает** и зачем вообще придумали слово «архитектура».

---

### Зачем вообще нужна архитектура

Архитектура появляется не тогда, когда проект маленький и красивый.
Она появляется тогда, когда проект:

* живёт больше пары месяцев
* развивается несколькими людьми
* переживает изменения требований

Без архитектуры код не «плохой», он просто начинает расти хаотично.
Любое изменение тянет за собой цепочку правок, а страх что-то сломать становится постоянным состоянием.

Архитектура — это способ ограничить хаос.

---

### Clean Architecture как идея, а не шаблон

**Clean Architecture** — это не конкретный набор классов и не папочная магия.
Это набор принципов, которые отвечают на один вопрос:
*кто от кого может зависеть*.

Главная идея проста:
**бизнес-логика не должна зависеть от деталей реализации**.

UI — деталь.
База данных — деталь.
Сеть — деталь.

Логика приложения должна уметь существовать без них.

---

### Слои Clean Architecture

В упрощённом виде Clean Architecture делит приложение на три слоя, которые нам уже знакомы:

**Presentation** — UI и состояние экранов
**Domain** — бизнес-логика и контракты
**Data** — реализация работы с данными

Ключевое правило:
зависимости всегда направлены **внутрь**, к domain.

Presentation может зависеть от domain.
Data может зависеть от domain.
Domain ни от кого не зависит.

Если dependency стрелка смотрит в другую сторону — что-то пошло не так.

---

### Domain — центр системы

Domain — это сердце приложения.
Он описывает:

* бизнес-модели
* правила работы с данными
* интерфейсы репозиториев

```kotlin
interface ItemsRepository {
    suspend fun loadItems(): List<Item>
}
```

Domain не знает:

* откуда приходят данные
* в каком формате
* как они отображаются

Он просто формулирует контракт.

Если завтра сеть заменится на локальный файл — domain это не волнует.

---

### Data — детали реализации

Data-слой реализует интерфейсы из domain.

```kotlin
class ItemsRepositoryImpl(
    private val apiService: ApiService,
    private val dao: ItemDao
) : ItemsRepository {

    override suspend fun loadItems(): List<Item> {
        // логика получения данных
    }
}
```

Здесь находится всё, что может меняться:

* Retrofit
* Room
* формат API
* кеширование

Clean Architecture не запрещает использовать фреймворки.
Она просто не даёт им протечь туда, где им быть не положено.

---

### Presentation — то, что видит пользователь

Presentation отвечает за отображение состояния и обработку действий пользователя.

ViewModel знает про domain и работает через интерфейсы.
UI знает только про ViewModel.

```kotlin
class ItemsViewModel(
    private val repository: ItemsRepository
) : ViewModel() {
    // состояние экрана
}
```

UI можно переписать:

* с XML на Compose
* с Compose обратно (не осуждаем)

Domain при этом останется прежним.

---

### Где здесь MVVM

MVVM — это архитектура **внутри presentation слоя**.
Она не конкурирует с Clean Architecture, а дополняет её.

Clean Architecture отвечает на вопрос *как устроено приложение в целом*.
MVVM — *как устроен экран*.

Поэтому они отлично живут вместе:

* Clean — про слои
* MVVM — про экраны

---

### UseCase и когда они нужны

Иногда между ViewModel и Repository добавляют **UseCase**.

```kotlin
class LoadItemsUseCase(
    private val repository: ItemsRepository
) {
    suspend operator fun invoke(): List<Item> {
        return repository.loadItems()
    }
}
```

UseCase имеет смысл, когда:

* логика сложная
* используется в нескольких местах
* требует тестирования отдельно от UI

Если UseCase просто вызывает один метод репозитория — он, скорее всего, лишний.
Clean Architecture не требует максимального количества классов, она требует осознанности.

---

### Типичные ошибки при использовании Clean Architecture

Самая частая ошибка — слепо копировать схему.

Появляются:

* UseCase без логики
* десятки папок
* классы, которые делают ровно одну строчку кода

Архитектура начинает мешать, а не помогать.

Clean Architecture — это инструмент.
Если он усложняет проект без причины, значит его применили неправильно.

---

### Итог

Clean Architecture не делает приложение быстрее, красивее или короче.
Она делает его **устойчивым к изменениям**.

Она не спасает от багов, но спасает от переписывания всего проекта.
И чем раньше в проекте появляется порядок, тем дольше он живёт без боли.

Если коротко:
архитектура нужна не для старта проекта, а для его выживания.
