## Мобильная разработка

или

### Что такое Android и с чем его едят

Начнём с приятного.

**Зарплаты**

![](./images/front_salary.png)

![](./images/android_salary.png)

Зарплаты мобильных разработчиков стабильно остаются высокими по рынку IT.
Android-разработчиков объективно меньше, чем веб-разработчиков.

При этом почти каждая крупная компания хочет иметь своё мобильное приложение.
Иногда даже не потому, что без него нельзя, а потому что *так принято*.
Отсутствие приложения всё чаще воспринимается как признак «несерьёзного» продукта.

![](./images/not_false_is_true.jpg)

---

### Почему именно мобильное приложение, а не сайт?

Если сильно упростить — потому что мобильное приложение живёт **внутри устройства пользователя**, а сайт — снаружи.

Приложение всегда под рукой.
Оно запускается одним нажатием, не требует открытия браузера, повторной авторизации и ожидания загрузки интерфейса. Даже при плохом интернете приложение может работать частично или полностью оффлайн — сайт в этот момент просто не существует.

Вторая важная причина — **интеграция с системой**.
Мобильное приложение — это часть операционной системы. Оно понимает системные темы, реагирует на настройки пользователя, может подстраиваться под тёмный режим, размер шрифтов, язык и поведение устройства в целом.
Сайт живёт в песочнице браузера и никогда не будет чувствовать себя «родным» так же глубоко.

Третья причина — **доступ к возможностям устройства**.
Камера, микрофон, контакты, геолокация, push-уведомления, фоновые задачи — всё это в мобильной разработке является нормой, а не костылём.
Да, веб умеет многое, но на мобильных платформах это по-прежнему работает стабильнее и предсказуемее.

Ну и последняя, но очень важная причина — **поведение пользователей**.
Люди проводят большую часть времени именно в приложениях.
Если сервис уже установлен, ему доверяют больше, его открывают чаще, к нему возвращаются охотнее.
С точки зрения бизнеса приложение — один из самых эффективных способов удержания пользователя.

![](./images/web_vs_android.jpg)

---

### Что такое Android

Android — это операционная система, изначально созданная для мобильных устройств, но со временем вышедшая далеко за их пределы.

Сегодня Android работает не только на смартфонах, но и на:

* умных часах
* телевизорах
* автомобильных системах
* интерактивных панелях
* кассовых аппаратах
* ноутбуках и гибридных устройствах

Фактически Android — это платформа для устройств с ограниченными ресурсами, где важно уметь работать аккуратно и эффективно.

Система построена на базе ядра Linux, но поверх него добавлен огромный слой собственных компонентов, сервисов и ограничений.
Разработчик работает не напрямую с Linux, а с Android SDK — набором инструментов и API, которые задают правила игры.

Что именно происходит внутри Android и как он управляет приложениями, мы подробно разберём в следующей лекции.

---

### Особенности разработки под Android

Android-приложение может играть очень разные роли.

Часто это второй frontend для существующего backend’а.
Веб-клиент и мобильное приложение обращаются к одному и тому же API, но по-разному показывают данные и по-разному взаимодействуют с пользователем.

Но Android-приложение может быть и полностью автономным.
Трекеры тренировок, заметки, текстовые редакторы, файловые менеджеры, медиаплееры — всё это может работать вообще без сервера.

За счёт этого Android одновременно совмещает плюсы и минусы frontend-разработки и desktop-приложений.
С одной стороны — интерфейс и взаимодействие с пользователем, с другой — доступ к системе и локальным ресурсам.

Отдельная особенность — **адаптивность**.
Устройств на Android огромное количество. Они отличаются:

* размером экрана
* разрешением
* объёмом памяти
* производительностью
* версиями системы

Приложение должно корректно работать на всём этом зоопарке.
SDK сильно помогает разработчику, но полностью проблему не решает — учитывать разнообразие устройств всё равно приходится.

---

### Потребности разработчика

Для Android-разработки используется **Android Studio** — официальная IDE от Google.
Она мощная, удобная… и довольно прожорливая.

Для комфортной работы понадобится:

* минимум 16 ГБ оперативной памяти
* терпение при первой индексации проекта
* и привычка периодически перезапускать IDE без чувства вины

Это не баг, это часть профессии.

![источник https://www.costafotiadis.com/post/exercises-in-futility-one-time-events-in-android](./images/flutter_is_not_better.avif)

### Android OS

#### Ядро Linux — фундамент Android

В самом низу Android находится **ядро Linux**.
Именно оно отвечает за базовые, но критически важные вещи: планирование процессов, работу с памятью, файловую систему, управление устройствами.

Android не изобретал это с нуля. Он взял Linux и сильно его адаптировал под мобильные устройства.
Поэтому многие идеи Android выглядят знакомо тем, кто сталкивался с серверными или Unix-подобными системами.

Но есть принципиальное отличие.
Если в классических ОС приложение считается «гостем», которому можно многое, то в Android приложение — это **потенциальная угроза**. Не потому что оно обязательно вредоносное, а потому что оно может быть плохо написано и съедать ресурсы батареи плохо собранного на китайском заводе устройства.

Отсюда вытекает почти всё, что мы видим дальше.

#### Процессы, пользователи и sandbox

Когда пользователь устанавливает приложение, Android делает для него отдельного пользователя на уровне Linux.
Да, буквально отдельного. Со своим UID, своими правами и своим пространством.

Когда приложение запускается, оно работает:

* в собственном процессе
* под собственным пользователем
* в собственной изолированной среде

Эта изоляция и называется **sandbox**.

Важно понять простую мысль:
приложения в Android **не видят друг друга**. Они не могут просто так обратиться к файлам другого приложения, посмотреть его память или узнать, что там происходит внутри.

Даже если два приложения написаны одной компанией и стоят на одном телефоне, для системы они — чужие.

Это решение резко повышает безопасность и стабильность системы, но для разработчика сразу накладывает ограничения.
Например, нельзя «поделиться» файлом напрямую — для этого нужны специальные механизмы, о которых Android явно знает и которые он контролирует.

Приложения могут общаться между собой, но транспортный уровень проложен также через ОС, что тоже накладывает ограничения разработчикам. Кому интересно, принцип работы описан [тут](/android/aidl.md).

#### Файловая система и каталоги приложения

У каждого приложения есть **свой каталог в файловой системе**.
Это его личное пространство, доступное только ему.

Внутри этого пространства приложение может:

* хранить файлы
* базы данных
* кеш
* временные данные

Другие приложения туда попасть не могут.
Даже если они знают путь — прав просто нет.

Это важный момент:
путь в файловой системе сам по себе ничего не значит без прав доступа.

Кроме приватного пространства, в Android существуют и **общие ресурсы**.
Например, общее хранилище (фотографии, видео, документы), к которому могут обращаться разные приложения.

Но доступ к таким ресурсам:

* строго контролируется
* требует разрешений
* со временем становится всё более ограниченным

Каждая новая версия Android делает шаг в сторону ещё большей изоляции.
Разработчик не может рассчитывать, что «раньше работало — значит и дальше будет».

#### Permissions как продолжение файловой изоляции

Логичным продолжением sandbox стала система **разрешений**.

Android исходит из идеи, что приложение по умолчанию **не имеет доступа ни к чему**.
Ни к камере, ни к микрофону, ни к файлам пользователя, ни к геолокации.

Если приложению что-то нужно, оно обязано:

1. явно заявить об этом
2. объяснить системе, зачем
3. получить согласие пользователя

Причём пользователь может:

* отказать
* отозвать разрешение позже
* дать доступ только «на время использования»

С точки зрения системы это логично.
С точки зрения разработчика — это означает, что приложение должно быть готово к отказу и уметь жить в неполной конфигурации.

#### Root-доступ и почему его нет у приложений

Если продолжать мысль про безопасность, логично задаться вопросом:
а почему приложения просто не получают полный доступ к системе?

Ответ простой: потому что тогда система перестанет быть стабильной.

На обычном Android-устройстве приложения **не имеют root-доступа**.
Они не могут менять системные файлы, управлять ядром или вмешиваться в работу других процессов.

Даже системные приложения живут в довольно жёстких рамках.

Android не доверяет приложениям настолько, чтобы отдавать им контроль над устройством.
И именно поэтому большинство телефонов живут годами, не превращаясь в кирпич после установки пары сомнительных программ.

#### Ограниченные ресурсы и управление процессами

Теперь, когда мы разобрались с изоляцией, появляется следующая проблема — ресурсы.

Телефон не может позволить себе держать в памяти всё подряд.
Поэтому Android постоянно следит за тем:

* сколько памяти занимает приложение
* активно ли оно сейчас
* нужно ли оно пользователю в данный момент

Если приложение уходит в фон, система может:

* остановить его
* выгрузить из памяти
* полностью завершить процесс

Это не ошибка и не баг.
Это нормальная политика управления ресурсами.

Именно отсюда берётся концепция жизненного цикла компонентов, к которой мы подойдём в следующей лекции.

#### Память и Garbage Collector

Приложения на Kotlin и Java работают в среде с **сборщиком мусора**.
Он автоматически отслеживает объекты в памяти и удаляет те, которые больше не используются.

Это сильно упрощает жизнь разработчику и избавляет от ручного управления памятью, но при этом создаёт опасную иллюзию, что о памяти можно вообще не думать.
На Android это не так.

Память ограничена, а сборка мусора — операция не бесплатная.
Если приложение активно создаёт временные объекты, особенно в UI-потоке, система рано или поздно будет вынуждена запускать очистку памяти чаще и агрессивнее.

В этот момент приложение может начать «подвисать». Интерфейс перестаёт отвечать, а пользователь видит, что экран как будто замер.
Если такая пауза длится слишком долго, Android считает, что приложение не отвечает, и показывает знакомое сообщение **ANR (Application Not Responding)** с предложением закрыть приложение.

Есть и более жёсткий сценарий.
Если приложение потребляет больше памяти, чем ему разрешено, и сборщик мусора уже не помогает, система завершает процесс с ошибкой **Out Of Memory Error**. В этом случае приложение просто падает, зачастую без красивых предупреждений.

Оба варианта — прямое следствие неаккуратной работы с памятью.
Именно поэтому в Android важно понимать, что происходит «под капотом», даже если язык программирования старается скрыть детали.

Подробнее можно почитать [тут](/basics/lowLevelConcepts/garbageCollector.md) и [тут](/basics/lowLevelConcepts/ram_arc.md)

#### Сервисы и фоновая работа

Иногда приложению нужно работать дольше, чем живёт экран.
Для этого в Android существуют **сервисы**.

Но сервис — это не «бессмертный поток».
Это строго контролируемый компонент, который должен объяснить системе, зачем он работает в фоне и почему его нельзя остановить.

Современный Android особенно не любит фоновую активность без причины.
Если сервис не объяснил своё существование — его закроют. И, скорее всего, правильно сделают.

---

### Kotlin

[источник вдохновения и букв](https://habr.com/ru/articles/848860/)

**Почему Kotlin, а не Java?**

Все просто - этот язык является новой формой Java для Android. В нем решили множество проблем из Java, сделали более приятный синтаксис и для Android он стал работать быстрее. В нем есть все функции из Java, но в Java нет некоторых функций из Kotlin.

Так же этот язык проще многих аналогов (того же Java) от чего начать его использовать куда проще, чем многие другие.

####  Почему Kotlin удобен на практике

Kotlin — это не просто «Java, но покороче».
Он изначально спроектирован так, чтобы **уменьшать количество ошибок**, **сокращать код** и **заставлять разработчика писать более осознанно**.

Рассмотрим несколько ключевых возможностей, за которые Kotlin особенно любят в Android-разработке.

#### `val` и `var`

В Kotlin переменные бывают двух видов:

* `val` — неизменяемая ссылка
* `var` — изменяемая

По умолчанию почти всегда используется `val`.
Это заставляет думать о состоянии данных и снижает количество багов, связанных с неожиданными изменениями.


Пример:
```kotlin
var lupa = "флорист"

val pupa = "повар"

// Ошибки нет
lupa = "помощник повара"

// Ошибка: val изменить невозможно
pupa = "помощник флориста"

```

Если значение действительно должно меняться — тогда используется `var`.
В итоге код становится более предсказуемым и легче читается: по объявлению сразу понятно, может ли переменная измениться.

#### Null safety

Одна из главных болей Java — `NullPointerException`.
В Kotlin эту проблему постарались решить на уровне языка.

Типы делятся на:

* не-null (`String`)
* nullable (`String?`)

Если переменная может быть `null`, это **обязательно отражается в типе**.
Компилятор не даст просто так обратиться к ней, пока ты явно не обработаешь этот случай.

В результате огромное количество ошибок ловится ещё **до запуска приложения**, а не в логах продакшена.

#### Scope-функции

Позволяют выполнить для некоторого объекта некоторый код в виде лямбда-выражения. При вызове подобной функции, создается временная область видимости. В этой области видимости можно обращаться к объекту без использования его имени.

По сути, все эти функции делают одно и то же: выполняют блок кода для объекта. Отличие состоит в том, как этот объект становится доступным внутри блока и каков результат всего выражения.

Общая таблица сравнения

|Функция|Контекстный объект|Return|Функция расширения|
|-|-|-|-|
|let|it|результат лямбды|+||
|run|this|результат лямбды|+||
|run|-|результат лямбды|- (может быть вызвана без)||
|with|this|результат лямбды|- (принимает объект как аргумент)||
|also|it|объект контекста|+||
|apply|this|объект контекста|+||

[подробнее здесь](/programming/syntaxKotlin/scopeFunctions.md)

#### Extension-функции

[источник](https://metanit.com/kotlin/tutorial/5.5.php)

позволяют добавить функционал к уже определенным типам. При этом типы могут быть определены где-то в другом месте, например, в стандартной библиотеке.

```kotlin
fun тип.имя_функции(параметры) : возвращаемый_тип{
    тело функции
}
```

По своей задумке, функция расширения Kotlin — это дополнительный метод для любого объекта, даже для потенциально несуществующего (нуллабельного). Этот инструмент является прямой реализацией переопределения методов паттерна проектирования Декоратор.

*ВАЖНО:* В функциях расширения мы можем обращаться к любым общедоступным свойствам и методам объекта, однако не можем обращаться к свойствам и методам с модификаторами private и protected.

*ВАЖНО:* Функции расширения не переопределяют функции, которые уже определены в классе. Если функция расширения имеет ту же сигнатуру, что и уже имеющаяся функция класса, то компилятор просто будет игнорировать подобную функцию расширения.

#### Статика без боли

В Kotlin нет привычных `static` методов из Java.
Вместо этого используются:

* `object`
* `companion object`
* top-level функции

Такой подход гибче и чище.
Не нужно городить утилитные классы только ради статики — функции могут жить прямо в файле, если им не нужен объект.

Это хорошо вписывается в архитектуру Android-приложений и упрощает структуру проекта.

#### Data-классы

`data class` — ещё одна вещь, которая экономит огромное количество времени.

Для классов, которые просто хранят данные, Kotlin автоматически генерирует:

* `equals`
* `hashCode`
* `toString`
* `copy`
* destructuring

То, что в Java занимало десятки строк кода, в Kotlin описывается одной строкой.
Это особенно удобно для моделей данных, DTO и состояний экранов.

[подробнее описано здесь](/programming/syntaxKotlin/classes.md)

#### Базовый синтаксис Kotlin

Синтаксис Kotlin старается быть максимально лаконичным и читаемым.
Большинство конструкций выглядят проще и короче, чем в Java, при этом остаются строгими и однозначными.

Функции в Kotlin объявляются с помощью ключевого слова `fun`.
Типы указываются **после** имени переменной или параметра, а не перед ним.

```kotlin
fun sum(a: Int, b: Int): Int {
    return a + b
}
```

Если функция состоит из одного выражения, можно опустить тело и `return`:

```kotlin
fun sum(a: Int, b: Int) = a + b
```

Классы объявляются очень просто.
Конструктор по умолчанию описывается прямо в заголовке класса:

```kotlin
class User(val name: String, var age: Int)
```

Здесь `name` и `age` одновременно являются параметрами конструктора и свойствами класса.
Не нужно писать отдельные поля, геттеры и сеттеры — они генерируются автоматически.

Если требуется логика внутри конструктора, используется блок `init`:

```kotlin
class User(val name: String) {
    init {
        println("User created: $name")
    }
}
```

Наследование указывается через двоеточие.
По умолчанию классы в Kotlin **закрыты для наследования**, поэтому для расширения класс нужно пометить как `open`:

```kotlin
open class Animal
class Dog : Animal()
```

Методы также по умолчанию `final`.
Чтобы их можно было переопределять, используется `open`, а для переопределения — `override`.

```kotlin
open class Animal {
    open fun speak() {}
}

class Dog : Animal() {
    override fun speak() {}
}
```

Уровни видимости в Kotlin немного отличаются от Java.
Основные модификаторы — `public`, `private`, `protected` и `internal`.

`public` используется по умолчанию.
`private` ограничивает доступ текущим файлом или классом.
`protected` работает только внутри класса и его наследников.
`internal` ограничивает видимость рамками модуля — это особенно полезно в больших проектах и библиотеках.

Переменные и свойства, как уже упоминалось, объявляются через `val` и `var`:

```kotlin
val id: Int = 1
var count: Int = 0
```

Тип часто можно не указывать — компилятор умеет выводить его сам:

```kotlin
val name = "Alex"
```

Kotlin активно использует выражения вместо операторов.
Например, `if` может возвращать значение:

```kotlin
val max = if (a > b) a else b
```

То же самое относится к `when`, который заменяет громоздкий `switch` из Java и используется намного шире.

В целом синтаксис Kotlin поощряет короткие, выразительные конструкции и минимальное количество шаблонного кода.
За счёт этого логика приложения становится виднее, а сам код — проще в поддержке и развитии.


---


### Проект Android и система сборки (Gradle)

Android-проект собирается с помощью **Gradle**.
В реальности это означает, что в проекте есть несколько `build.gradle` файлов, и именно в них описывается, *что мы собираем и как*.

Типичный `build.gradle` модуля приложения выглядит примерно так:

```gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    compileSdk 34

    defaultConfig {
        applicationId "com.example.myapp"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
        }
    }
}

dependencies {
    implementation "androidx.core:core-ktx:1.12.0"
    implementation "androidx.appcompat:appcompat:1.6.1"
}
```

Здесь описывается почти всё:
какую версию Android SDK мы используем, под какие версии системы можно установить приложение, какие библиотеки подключены.

Важно понимать, что Gradle — это не «код приложения».
Это описание среды, в которой приложение **может быть собрано и запущено**. Большая часть боли с Gradle возникает именно потому, что ошибки здесь выглядят непривычно и часто не связаны напрямую с логикой приложения.

![источник https://www.costafotiadis.com/post/exercises-in-futility-jetpack-compose-recomposition](./images/gradle_build.png)

#### JDK и ещё один источник боли

Отдельного упоминания заслуживает **JDK**.

Android использует Java-инструменты для компиляции, даже если мы пишем на Kotlin.
Из-за этого версия JDK имеет значение. И иногда очень большое.

Слишком старая версия — проект не собирается.
Слишком новая — плагины не поддерживают.
Неправильно настроенная — Android Studio будет вести себя странно.

На этом этапе важно не столько разбираться во всех деталях, сколько понимать:
если сборка не работает, проблема часто не в коде, а в окружении.

Со временем это перестаёт быть болью и становится рутиной. Но первый опыт почти у всех одинаковый.

---

### Activity — точка входа в приложение

Когда приложение всё-таки собирается и запускается, Androidу нужно понять, **что именно он должен показать пользователю**.
Для этого в системе существует компонент под названием **Activity**.

Activity — это экран приложения.
Точнее, это связка логики и интерфейса, которая отвечает за конкретное взаимодействие с пользователем.

Важно понимать, что Activity:

* не живёт вечно
* может быть уничтожена системой
* может быть пересоздана в любой момент

Это напрямую связано с тем, о чём мы говорили во второй лекции: управление памятью и ресурсами.

#### Жизненный цикл Activity

У Activity есть **жизненный цикл** — последовательность состояний, через которые она проходит.

Activity создаётся, становится видимой, получает фокус, может уходить в фон, а потом быть уничтоженной.
И всё это — под контролем Android, а не разработчика.

Система не спрашивает, удобно ли сейчас уничтожать экран.
Если нужно освободить ресурсы — она это сделает.

Поэтому разработчик обязан:

* корректно реагировать на переходы между состояниями
* не хранить критичные данные напрямую в Activity
* быть готовым к пересозданию экрана

Именно здесь многие впервые понимают, что Android — не про «написал код и он всегда работает», а про постоянный диалог с системой.

---

### XML как основа классического UI


![](./images/jmix_android_xml_meme.jpg)


В классическом Android интерфейс описывается с помощью **XML**.
XML — это декларативное описание экрана: мы говорим *что есть*, а не *как рисовать по шагам*.

Простейший пример layout-файла:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Привет, Android"
        android:textSize="20sp" />

    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Нажми меня" />

</LinearLayout>
```

Этот файл описывает экран, но **не содержит логики**.
Он не знает, что произойдёт при нажатии кнопки — этим занимается Activity или другой компонент.

Такое разделение выглядит громоздким, но оно позволяет системе:
адаптировать интерфейс под разные экраны, языки и ориентации без переписывания логики.

---

В итоге Android-разработка — это не «просто ещё один frontend».
Это отдельный мир со своими правилами, ограничениями и возможностями.

И прежде чем писать первый экран, полезно понять, **на какой платформе мы вообще работаем**.
С этим как раз и начнём в следующей лекции.
