## Лекция 3 — Основы Android-разработки

### Gradle, UI, XML и Activity

На прошлой лекции мы разобрали, как устроен Android как операционная система и почему он так жёстко относится к приложениям.
Теперь пора перейти от устройства системы к тому, **как в ней пишутся приложения**.

С этого момента Android перестаёт быть абстрактной платформой и начинает проявляться в виде инструментов, файлов и кода. И именно здесь у многих возникает первое ощущение, что «всё слишком сложно».

Спойлер: сложно не потому, что плохо придумано, а потому что Android решает много задач одновременно.

---

### Проект Android и система сборки (Gradle)

Android-проект собирается с помощью **Gradle**.
В реальности это означает, что в проекте есть несколько `build.gradle` файлов, и именно в них описывается, *что мы собираем и как*.

Типичный `build.gradle` модуля приложения выглядит примерно так:

```gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    compileSdk 34

    defaultConfig {
        applicationId "com.example.myapp"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
        }
    }
}

dependencies {
    implementation "androidx.core:core-ktx:1.12.0"
    implementation "androidx.appcompat:appcompat:1.6.1"
}
```

Здесь описывается почти всё:
какую версию Android SDK мы используем, под какие версии системы можно установить приложение, какие библиотеки подключены.

Важно понимать, что Gradle — это не «код приложения».
Это описание среды, в которой приложение **может быть собрано и запущено**. Большая часть боли с Gradle возникает именно потому, что ошибки здесь выглядят непривычно и часто не связаны напрямую с логикой приложения.

![источник https://www.costafotiadis.com/post/exercises-in-futility-jetpack-compose-recomposition](./images/gradle_build.png)

---

### JDK и ещё один источник боли

Отдельного упоминания заслуживает **JDK**.

Android использует Java-инструменты для компиляции, даже если мы пишем на Kotlin.
Из-за этого версия JDK имеет значение. И иногда очень большое.

Слишком старая версия — проект не собирается.
Слишком новая — плагины не поддерживают.
Неправильно настроенная — Android Studio будет вести себя странно.

На этом этапе важно не столько разбираться во всех деталях, сколько понимать:
если сборка не работает, проблема часто не в коде, а в окружении.

Со временем это перестаёт быть болью и становится рутиной. Но первый опыт почти у всех одинаковый.

---

### Activity — точка входа в приложение

Когда приложение всё-таки собирается и запускается, Androidу нужно понять, **что именно он должен показать пользователю**.
Для этого в системе существует компонент под названием **Activity**.

Activity — это экран приложения.
Точнее, это связка логики и интерфейса, которая отвечает за конкретное взаимодействие с пользователем.

Важно понимать, что Activity:

* не живёт вечно
* может быть уничтожена системой
* может быть пересоздана в любой момент

Это напрямую связано с тем, о чём мы говорили во второй лекции: управление памятью и ресурсами.

---

### Жизненный цикл Activity

У Activity есть **жизненный цикл** — последовательность состояний, через которые она проходит.

Activity создаётся, становится видимой, получает фокус, может уходить в фон, а потом быть уничтоженной.
И всё это — под контролем Android, а не разработчика.

Система не спрашивает, удобно ли сейчас уничтожать экран.
Если нужно освободить ресурсы — она это сделает.

Поэтому разработчик обязан:

* корректно реагировать на переходы между состояниями
* не хранить критичные данные напрямую в Activity
* быть готовым к пересозданию экрана

Именно здесь многие впервые понимают, что Android — не про «написал код и он всегда работает», а про постоянный диалог с системой.

---

### UI в Android и Material Design

Интерфейс в Android — это не просто набор кнопок и текстов.
Это целая система, которая должна:

* выглядеть нативно
* быть удобной
* адаптироваться под разные экраны
* поддерживать темы и стили

Google предлагает **Material Design** — набор принципов и компонентов, которые задают визуальный и поведенческий стандарт.

Material — это не строгий закон, а рекомендация.
Можно делать иначе, но если идти против системы, придётся решать больше проблем самостоятельно.

Android даёт огромные возможности для кастомизации UI, но при этом поощряет использование стандартных компонентов. Это баланс между свободой и единообразием.

---

### XML как основа классического UI


![](./images/jmix_android_xml_meme.jpg)


В классическом Android интерфейс описывается с помощью **XML**.
XML — это декларативное описание экрана: мы говорим *что есть*, а не *как рисовать по шагам*.

Простейший пример layout-файла:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Привет, Android"
        android:textSize="20sp" />

    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Нажми меня" />

</LinearLayout>
```

Этот файл описывает экран, но **не содержит логики**.
Он не знает, что произойдёт при нажатии кнопки — этим занимается Activity или другой компонент.

Такое разделение выглядит громоздким, но оно позволяет системе:
адаптировать интерфейс под разные экраны, языки и ориентации без переписывания логики.

---

### Списки и RecyclerView

Почти любое Android-приложение работает со списками.
Создавать отдельный View для каждого элемента списка — дорого и неэффективно.

Поэтому в Android используется **RecyclerView** — компонент, который переиспользует элементы интерфейса.

Пример описания RecyclerView в XML:

```xml
<androidx.recyclerview.widget.RecyclerView
    android:id="@+id/recyclerView"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

Сам по себе RecyclerView ничего не показывает.
Он работает в связке с **адаптером**, который говорит, как создавать и заполнять элементы списка.

Упрощённый пример адаптера:

```kotlin
class SimpleAdapter(
    private val items: List<String>
) : RecyclerView.Adapter<SimpleAdapter.ViewHolder>() {

    class ViewHolder(val textView: TextView) :
        RecyclerView.ViewHolder(textView)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val textView = TextView(parent.context)
        return ViewHolder(textView)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.textView.text = items[position]
    }

    override fun getItemCount(): Int = items.size
}
```

Идея здесь ключевая:
RecyclerView не хранит все элементы списка одновременно. Он переиспользует View, которые вышли за пределы экрана, тем самым экономя память и повышая производительность.

Это один из ярких примеров того, как Android заставляет разработчика думать об эффективности, даже в UI.

---

### Итог

В этой лекции мы впервые столкнулись с Android как с **платформой разработки**, а не просто с ОС.

Мы увидели:

* систему сборки и её особенности
* роль JDK
* Activity и её жизненный цикл
* основы UI и Material Design
* XML и работу со списками

Дальше мы начнём постепенно уходить от «Activity как центра всего» и разбираться, **как правильно разделять логику и интерфейс**, чтобы приложение было устойчивым и поддерживаемым.

Именно этому будет посвящена следующая лекция — про архитектуру, состояние и MVVM.

