## Лекция 3 — Основы Android-разработки

### Gradle, UI, XML и Activity

На прошлой лекции мы разобрали, как устроен Android как операционная система и почему он так жёстко относится к приложениям.
Теперь пора перейти от устройства системы к тому, **как в ней пишутся приложения**.

С этого момента Android перестаёт быть абстрактной платформой и начинает проявляться в виде инструментов, файлов и кода. И именно здесь у многих возникает первое ощущение, что «всё слишком сложно».

Спойлер: сложно не потому, что плохо придумано, а потому что Android решает много задач одновременно.

---


---

### UI в Android и Material Design

Интерфейс в Android — это не просто набор кнопок и текстов.
Это целая система, которая должна:

* выглядеть нативно
* быть удобной
* адаптироваться под разные экраны
* поддерживать темы и стили

Google предлагает **Material Design** — набор принципов и компонентов, которые задают визуальный и поведенческий стандарт.

Material — это не строгий закон, а рекомендация.
Можно делать иначе, но если идти против системы, придётся решать больше проблем самостоятельно.

Android даёт огромные возможности для кастомизации UI, но при этом поощряет использование стандартных компонентов. Это баланс между свободой и единообразием.

---



---

### Списки и RecyclerView

Почти любое Android-приложение работает со списками.
Создавать отдельный View для каждого элемента списка — дорого и неэффективно.

Поэтому в Android используется **RecyclerView** — компонент, который переиспользует элементы интерфейса.

Пример описания RecyclerView в XML:

```xml
<androidx.recyclerview.widget.RecyclerView
    android:id="@+id/recyclerView"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

Сам по себе RecyclerView ничего не показывает.
Он работает в связке с **адаптером**, который говорит, как создавать и заполнять элементы списка.

Упрощённый пример адаптера:

```kotlin
class SimpleAdapter(
    private val items: List<String>
) : RecyclerView.Adapter<SimpleAdapter.ViewHolder>() {

    class ViewHolder(val textView: TextView) :
        RecyclerView.ViewHolder(textView)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val textView = TextView(parent.context)
        return ViewHolder(textView)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.textView.text = items[position]
    }

    override fun getItemCount(): Int = items.size
}
```

Идея здесь ключевая:
RecyclerView не хранит все элементы списка одновременно. Он переиспользует View, которые вышли за пределы экрана, тем самым экономя память и повышая производительность.

Это один из ярких примеров того, как Android заставляет разработчика думать об эффективности, даже в UI.

---

### Итог

В этой лекции мы впервые столкнулись с Android как с **платформой разработки**, а не просто с ОС.

Мы увидели:

* систему сборки и её особенности
* роль JDK
* Activity и её жизненный цикл
* основы UI и Material Design
* XML и работу со списками

Дальше мы начнём постепенно уходить от «Activity как центра всего» и разбираться, **как правильно разделять логику и интерфейс**, чтобы приложение было устойчивым и поддерживаемым.

Именно этому будет посвящена следующая лекция — про архитектуру, состояние и MVVM.

