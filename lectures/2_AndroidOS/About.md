## Лекция 2 — Android OS

### Что под капотом и как это работает

В первой лекции мы говорили об Android как о платформе для приложений.
Теперь попробуем посмотреть на него не глазами пользователя и даже не совсем глазами разработчика, а глазами операционной системы.

Это важно, потому что Android — система строгая.
Она не пытается угодить приложению. Она пытается выжить сама, сохранить батарею, память и нервы пользователя. Всё остальное — вторично.

---

### Ядро Linux — фундамент Android

В самом низу Android находится **ядро Linux**.
Именно оно отвечает за базовые, но критически важные вещи: планирование процессов, работу с памятью, файловую систему, управление устройствами.

Android не изобретал это с нуля. Он взял Linux и сильно его адаптировал под мобильные устройства.
Поэтому многие идеи Android выглядят знакомо тем, кто сталкивался с серверными или Unix-подобными системами.

Но есть принципиальное отличие.
Если в классических ОС приложение считается «гостем», которому можно многое, то в Android приложение — это **потенциальная угроза**. Не потому что оно обязательно вредоносное, а потому что оно может быть плохо написано и съедать ресурсы батареи плохо собранного на китайском заводе устройства.

Отсюда вытекает почти всё, что мы видим дальше.

---

### Процессы, пользователи и sandbox

Когда пользователь устанавливает приложение, Android делает для него отдельного пользователя на уровне Linux.
Да, буквально отдельного. Со своим UID, своими правами и своим пространством.

Когда приложение запускается, оно работает:

* в собственном процессе
* под собственным пользователем
* в собственной изолированной среде

Эта изоляция и называется **sandbox**.

Важно понять простую мысль:
приложения в Android **не видят друг друга**. Они не могут просто так обратиться к файлам другого приложения, посмотреть его память или узнать, что там происходит внутри.

Даже если два приложения написаны одной компанией и стоят на одном телефоне, для системы они — чужие.

Это решение резко повышает безопасность и стабильность системы, но для разработчика сразу накладывает ограничения.
Например, нельзя «поделиться» файлом напрямую — для этого нужны специальные механизмы, о которых Android явно знает и которые он контролирует.

Приложения могут общаться между собой, но транспортный уровень проложен также через ОС, что тоже накладывает ограничения разработчикам. Кому интересно, принцип работы описан [тут](/android/aidl.md).

---

### Файловая система и каталоги приложения

У каждого приложения есть **свой каталог в файловой системе**.
Это его личное пространство, доступное только ему.

Внутри этого пространства приложение может:

* хранить файлы
* базы данных
* кеш
* временные данные

Другие приложения туда попасть не могут.
Даже если они знают путь — прав просто нет.

Это важный момент:
путь в файловой системе сам по себе ничего не значит без прав доступа.

Кроме приватного пространства, в Android существуют и **общие ресурсы**.
Например, общее хранилище (фотографии, видео, документы), к которому могут обращаться разные приложения.

Но доступ к таким ресурсам:

* строго контролируется
* требует разрешений
* со временем становится всё более ограниченным

Каждая новая версия Android делает шаг в сторону ещё большей изоляции.
Разработчик не может рассчитывать, что «раньше работало — значит и дальше будет».

---

### Permissions как продолжение файловой изоляции

Логичным продолжением sandbox стала система **разрешений**.

Android исходит из идеи, что приложение по умолчанию **не имеет доступа ни к чему**.
Ни к камере, ни к микрофону, ни к файлам пользователя, ни к геолокации.

Если приложению что-то нужно, оно обязано:

1. явно заявить об этом
2. объяснить системе, зачем
3. получить согласие пользователя

Причём пользователь может:

* отказать
* отозвать разрешение позже
* дать доступ только «на время использования»

С точки зрения системы это логично.
С точки зрения разработчика — это означает, что приложение должно быть готово к отказу и уметь жить в неполной конфигурации.

---

### Root-доступ и почему его нет у приложений

Если продолжать мысль про безопасность, логично задаться вопросом:
а почему приложения просто не получают полный доступ к системе?

Ответ простой: потому что тогда система перестанет быть стабильной.

На обычном Android-устройстве приложения **не имеют root-доступа**.
Они не могут менять системные файлы, управлять ядром или вмешиваться в работу других процессов.

Даже системные приложения живут в довольно жёстких рамках.

Android не доверяет приложениям настолько, чтобы отдавать им контроль над устройством.
И именно поэтому большинство телефонов живут годами, не превращаясь в кирпич после установки пары сомнительных программ.

---

### Ограниченные ресурсы и управление процессами

Теперь, когда мы разобрались с изоляцией, появляется следующая проблема — ресурсы.

Телефон не может позволить себе держать в памяти всё подряд.
Поэтому Android постоянно следит за тем:

* сколько памяти занимает приложение
* активно ли оно сейчас
* нужно ли оно пользователю в данный момент

Если приложение уходит в фон, система может:

* остановить его
* выгрузить из памяти
* полностью завершить процесс

Это не ошибка и не баг.
Это нормальная политика управления ресурсами.

Именно отсюда берётся концепция жизненного цикла компонентов, к которой мы подойдём в следующей лекции.

---

### Память и Garbage Collector

Приложения на Kotlin и Java работают в среде с **сборщиком мусора**.
Он автоматически отслеживает объекты в памяти и удаляет те, которые больше не используются.

Это сильно упрощает жизнь разработчику и избавляет от ручного управления памятью, но при этом создаёт опасную иллюзию, что о памяти можно вообще не думать.
На Android это не так.

Память ограничена, а сборка мусора — операция не бесплатная.
Если приложение активно создаёт временные объекты, особенно в UI-потоке, система рано или поздно будет вынуждена запускать очистку памяти чаще и агрессивнее.

В этот момент приложение может начать «подвисать». Интерфейс перестаёт отвечать, а пользователь видит, что экран как будто замер.
Если такая пауза длится слишком долго, Android считает, что приложение не отвечает, и показывает знакомое сообщение **ANR (Application Not Responding)** с предложением закрыть приложение.

Есть и более жёсткий сценарий.
Если приложение потребляет больше памяти, чем ему разрешено, и сборщик мусора уже не помогает, система завершает процесс с ошибкой **Out Of Memory Error**. В этом случае приложение просто падает, зачастую без красивых предупреждений.

Оба варианта — прямое следствие неаккуратной работы с памятью.
Именно поэтому в Android важно понимать, что происходит «под капотом», даже если язык программирования старается скрыть детали.

Подробнее можно почитать [тут](/basics/lowLevelConcepts/garbageCollector.md) и [тут](/basics/lowLevelConcepts/ram_arc.md)

---

### Сервисы и фоновая работа

Иногда приложению нужно работать дольше, чем живёт экран.
Для этого в Android существуют **сервисы**.

Но сервис — это не «бессмертный поток».
Это строго контролируемый компонент, который должен объяснить системе, зачем он работает в фоне и почему его нельзя остановить.

Современный Android особенно не любит фоновую активность без причины.
Если сервис не объяснил своё существование — его закроют. И, скорее всего, правильно сделают.

---

### Итог

Android — это система, построенная вокруг идей:

* изоляции
* минимального доверия
* жёсткого контроля ресурсов

Все ограничения, с которыми мы сталкиваемся при разработке, вытекают именно отсюда, а не из чьей-то прихоти.

На следующей лекции мы перейдём от устройства системы к **конкретным компонентам разработки** и начнём разбирать, как всё это проявляется в реальном коде: сборка, UI и жизненный цикл Activity.

Если хочешь, дальше можем:

* сделать ещё более «системную» версию (почти как ввод в ОС)
* или наоборот, поджать текст под формат слайдов, сохранив глубину
